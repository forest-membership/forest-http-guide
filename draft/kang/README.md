# Kang

## 의문점 또는 이야기하면 좋을 사항

1. **HTTP 완벽 가이드 10P, 1.4.3 웹 페이지는 여러 객체로 이루어질 수도 있다.**

   이 부분에 대한 자세한 설명이 있었으면 좋겠다, 정확히 어떠한 의미로 서술되어 있는 것인지, 감이 잘 오지 않는다.

2. **HTTP 완벽 가이드 19~20P, 1.8 웹의 구성 요소**
3. URN와 현실 세계의 location 좌표 비교를 통한 이해 \(for what3words\)
4. **HTTP 완벽 가이드 32P,** 서버는 왜 네트워크 포트를 지정해서 열어놓을까?
5. HTTP에서의 사용자 이름과 비밀번호 사용 예와, 실제 서버에서는 질의를 통해서 구별하고 있는 것인지에 대해서. \(크롤링 제한?\) 결론적으로, 사용자 이름, 비밀번호, 파라미터, 질의의 사용 구분에 대하여.
6. **HTTP 완벽 가이드 39P, 그림 2-5 상대 URL을 절대 URL로 변환하기**
7. 
## 1장 HTTP 개관

이 챕터는 아래의 내용에 대해서 이야기할 것이다.

1. 얼마나 많은 클라이언트와 서버가 통신을 하는지
2. 리소스 \(웹 콘텐츠\)가 어디서 오는지
3. 웹 트랙잭션이 어떻게 동작하는지
4. HTTP 통신을 위해 사용되는 메시지의 형식
5. HTTP 기저의 TCP 네트워크 전송
6. 여러 종류의 HTTP 프로토콜
7. 인터넷 곳곳에 설치된 다양한 HTTP 구성 요소

### 1.1 인터넷 멀티미디어 배달부

인터넷 상에는 텍스트, 이미지, 영상 등 다양한 형식의 정보가 존재한다. HTTP는 이 정보들을, 사람들의 PC에 설치된 브라우저로, 이 대량의 정보를 정확하고 신속하게 전달한다. HTTP는 **신뢰성 있는 데이터 전송 프로토콜**을 사용하기 때문에, 데이터가 전송 중에 꼬이거나 손상되지 않음을 보장할 수 있다. 덕분에 사용자, 그리고 개발자들은 자신의 정보의 무결성에 대해서, 직접 확인할 필요가 사라졌다. 개발자들은 이제 인터넷의 결함이나 약점에 대한 걱정없이 애플리케이션 고유의 기능을 구현하는 데에 집중할 수 있다.

### 1.2 웹 클라이언트와 서버

웹 콘텐츠는 웹 서버에 존재한다. 웹 서버는 HTTP 프로토콜로 소통하기 때문에 HTTP 서버라고도 한다. 이들 웹 서버는 인터넷에 데이터를 저장하고, HTTP 클라이언트가 요청한 데이터를 제공한다. 예를 들어, 특정 도메인의 html을 열어볼 경우, 웹 브라우저는 해당 도메인의 웹 서버로 HTTP 요청을 보낸다. 서버는 요청을 해석하여 html을 찾고, 성공할 시 그것의 타입과 길이 등 부가적인 정보와 함께 클라이언트에게 돌려준다. 이 때도 역시 HTTP 응답에 실어서 보낸다.

### 1.3 리소스

웹 서버는 웹 리소스를 관리하고 제공한다. 가장 단순한 웹 리소스는 웹 서버 파일 시스템의 정적 파일이다. 그러나 모든 리소스가 정적일 필요는 없다. 리소스는 요청에 따라 콘텐츠를 생산하는 프로그램이 될 수도 있다. 라이브 영상을 보여주거나, 주식 거래, 부동산 데이터 베이스 검색, 온라인 쇼핑몰이 그러하다.

#### **1.3.1 미디어 타입**

각기 다른 전자 메일 시스템 사이에서 메시지가 오갈 때 겪는 문제점을 해결하고자, **MIME\(Multi purpose Internet Mail Extensions**, 다목적 인터넷 메일 확장\)이 만들어졌다. 이것이 매우 잘 동작했기 때문에 HTTP에서도 멀티미디어 콘텐츠를 기술하고 라벨을 붙이기 위해서 채택되었다. 웹 서버는 모든 HTTP 객체 데이터에 MIME 타입을 붙인다. 웹 브라우저는 서버로부터 객체를 돌려 받을 때 다룰 수 있는 객체가 맞는지, MIME 타입을 통해서 확인할 수 있다. MIME 타입은 사선\(/\)으로 구분된 주 타입\(Primary object type\)과 부 타입\(specific subtype\)으로 이루어진 문자열 라벨이다. 예를 들면 아래와 같다.

* html로 작성된 텍스트 문서 &gt; text/html
* plain ASCII 텍스트 문서 &gt; text/plain
* JPEG 이미지 &gt; image/jpeg
* GIF 이미지 &gt; image/gif
* 애플 퀵 타임 동영상 &gt; video/quicktime
* 마이크로소프트 파워포인트 프레젠테이션 &gt; application/vnd.ms-powerpoint

#### **1.3.2 URI**

웹 서버 리소스는 각자 이름을 가지고 있어서 클라이언트는 이를 통해 리소스를 지목할 수 있다. 이 리소스 이름을 통합 자원 식별자\(URL, Uniform Resource Identifier\) 라고 한다. 클라이언트는 이 URI을 가지고 정보 리소스, 즉 웹에 있는 이미지나 영상 등 단일 객체를 하나 하나 지목할 수 있다.

> [http://www.joes-hardware.com/specials/saw-blade.gif](http://www.joes-hardware.com/specials/saw-blade.gif)
>
> 첫째, HTTP를 사용하라.
>
> 둘째, [www.joes-hardware.com](https://github.com/forest-membership/forest-http-guide/tree/f80b4aceade83decc5ce5092e40206cd5fd11545/draft/www.joes-hardware.com)으로 이동하라
>
> 셋째, /specials/saw-blade.gif 라는 이름의 리소스를 가져와라.

#### **1.3.2.1 URL**

통합 자원 지시자\(URL, Uniform Resource Locator\)는 리소스 식별자의 가장 흔한 형태이다. 오늘 날 대부분 URI는 URL의 형태로 되어 있다. 대부분의 URL은 세 부분으로 이루어진 표준 포맷을 따르는데, 첫번째 부분은 스킴, 두번째 부분은 서버의 인터넷 주소, 세번째는 리소스를 가리킨다. 여기서 스킴이란, 리소스에 접근하기 위한 프로토콜로, 보통은 HTTP 프로토콜\(http://\) 이다.

#### **1.3.2.2 URN**

URI의 두번쨰 종류는 유니폼 리소스 이름 \(URN, Uniform Resource Name\)이다. URN은 콘텐츠를 이루는 한 리소스에 대해, 그 리소스의 **위치에 영향을 받지 않는 유일무이한 이름 역할**을 한다. 이 위치 독립적인 URN은 어디에 있든 문제없이 동작한다. 리소스가 이름을 유지하는 한, 다른 프로토콜로 접근하더라도 문제가 없다. URN은 효율적인 동작을 위해 리소스 위치를 분석하는 인프라 자원이 필요한데, 이는 아직 부재 중이다. 따라서 아직 실험 중인 상태고 널리 채택되지 않았다. URN의 전망은 밝지만, 이러한 까닭에 편의 및 통상적인 관례에 따라 URI와 URL의 별도 구분을 두지 않는다.

### 1.4 트랙잭션

HTTP 트랙잭션은 요청 명령과 응답 결과로 이루어져 있다.

* 요청 명령
  * GET / special/saw-blade.gif HTTP/1.0 Host: [www.joes-hardware.com](https://github.com/forest-membership/forest-http-guide/tree/f80b4aceade83decc5ce5092e40206cd5fd11545/draft/www.joes-hardware.com)
* 응답 결과
  * HTTP/1.0 200 OK Content-type: image/gif Content-length: 8572

#### **1.4.1 메서드**

HTTP 요청 메시지는 1개의 메서드를 가진다. 메서드는 서버에서 어떤 동작이 취해져야 하는지를 뜻한다. 흔히 GET, PUT, DELETE, POST, HEAD를 쓴다.

#### 1.4.2 상태 코드

모든 HTTP 응답 메시지는 상태 코드를 가진다. 상태 코드는 클라이언트에게 요청에 대한 결과를 알려주는 세 자리 숫자이다.

#### 1.4.3 웹 페이지는 여러 객체로 이루어질 수도 있다

웹 브라우저는 ‘시각적으로 풍부한’ 웹 페이지를 호출할 때 여러 차례의 HTTP 트랜잭션을 수행한다. HTML을 가져온 후, 나머지 리소스들을 위한 트랜잭션이 실행된다. 이 때, 리소스들은 각기 다른 서버에 존재할 수도 있다. **웹 페이지는 리소스가 아닌, 리소스의 모음이다.**

### 1.5 메시지

위에, 트랜잭션은 요청과 응답으로 이루어져 있고, 다시 그것들은 메서드, 상태 코드 등으로 이루어져 있다고 서술하였다. 각 메시지들을 더 자세히 볼 때, HTTP 메시지들은 아래와 같은 특징을 지닌다.

1. **이진 형식이 아닌 일반 텍스트\(String\)**이기 때문에 사람이 읽고 쓰기 편하게 되어 있다.

   어떤 프로그래머들은, 이진 형식이나 엄격한 텍스트 구조였다면 처리가 편하고 속도가 빨랐을 것이라고 말하지만, HTTP는 확장과 디버그가 용이하여 대다수에게는 좋은 평가를 받고 있다.

2. 요청과 응답 결과는 유사한 형식으로 이루어져 있는데, 아래의 세 가지 구조를 지닌다. 1. 시작 줄 : 요청이라면 무엇을 해야 하는 것인지, 응답이라면 무엇이 일어났는지를 말한다.

   \(GET /test/hi-there.txt HTTP/1.0 또는 HTTP/1.0 200 OK\)

   1. 헤더 \(header\) : 시작 줄 다음에는 0개 이상의 헤더 필드가 존재하고, 이 헤더 필드는 쌍점으로 구분되어 하나의 이름에 하나의 값을 지닌다.

      헤더는 한 줄에 1개 씩만 존재하며, 마지막에는 빈 줄 하나를 두어 본문과 구분을 둔다.

   2. 본문 \(body\) : 요청의 본문은 웹 서버로 데이터를 보내며, 응답은 역으로 반환한다. 본문은 임의의 이진 데이터를 포함할 수도 있다. \(ex. image\)

#### 1.5.1 간단한 메시지의 예

책 본문 참고 바람.

### 1.6 TCP 커넥션

TCP \(Transmission Control Protocol, 전송 제어 프로토콜\) 커넥션을 통해 메시지는 한 곳에서 다른 곳으로 이동된다.

#### 1.6.1 TCP/IP

HTTP는 애플리케이션 계층 프로토콜이다. HTTP는 네트워크 통신의 핵심적인 세부 사항에 대해서 신경쓰지 않는다. 이러한 과정은 신뢰성 있고 대중적인 프로토콜인 TCP/IP 에게 맡긴다. TCP는 아래의 세 가지를 제공한다.

1. 오류 없는 데이터 전송
2. 순서에 맞는 전달 \(데이터는 보낸 순서로 도착한다.\)
3. 조각나지 않는 데이터 스트림 \(언제든 어떤 크기로든 보낼 수 있다.\)
   * 속도 면에서 우수하나 위의 특성을 지니지 못한 것으로, UDP 프로토콜이 있으니, 관심있는 사람은 별도로 확인하길 바람.

인터넷 자체가 TCP/IP에 기초하고 있는데, **TCP/IP란 TCP와 IP가 층을 이루는, 패킷 교환 네트워크 프로토콜의 집합**이다. TCP/IP는 각 네트워크와 하드웨어의 특성을 숨기고, 어떤 종류의 컴퓨터나 네트워크든 서로 신뢰성 있는 의사소통을 하게 해준다. 일단 TCP 커넥션이 맺어지면 클라이언트와 서버 컴퓨터 간에 교환되는 메시지가 없어지거나, 손상되거나, 순서가 바뀌는 일은 켤고 없다. 네트워크 개념 상 HTTP 프로토콜은 TCP 위의 계층이다. 계층 순서는 4계층, 5계층, 7계층 등 경우에 따라 따로 분리하곤 하는데, 이 책의 HTTP 네트워크 프로토콜 스택은 HTTP &gt; TCP &gt; IP &gt; 네트워크를 위한 인터페이스 &gt; 물리적인 네트워크 하드웨어로 이어진다.

#### 1.6.2 접속. IP 주소 그리고 포트번호

HTTP 클라이언트는 서버에 메시지를 전송하기 전에 TCP/IP 커넥션을 맺어야 한다. TCP/IP는 두 컴퓨터 사이의 연결선 역할을 수행한다. TCP에서는 서버 컴퓨터에 대한 IP 주소와, 실행 중인 프로그램의 포트 번호를 필요로 한다. **이 IP주소와 포트 번호가 다시 앞에서 말한 URL**이다. **도메인**\(또는 호스트 명\)으로 되어 있는 경우도, DNS\(Domain Name Service\)에 의해 쉽게 IP주소와 포트 번호로 변환이 가능하다.

1. 웹 브라우저는 서버의 URL에서 호스트 명을 추출한다.
   1. 만약 URL이 도메인으로 되어 있다면, 서버의 호스트 명을 IP로 변환한다. 대부분은 이 단계를 거쳐야 한다.
   2. URL에 포트 번호가 있다면, 포트 번호를 추출한다.
2. 웹 브라우저는 웹 서버와 TCP 커넥션을 맺는다.
3. 웹 브라우저는 서버에 HTTP 요청을 보낸다.
4. 서버는 웹 브라우저에 HTTP 응답을 보낸다.
5. 커넥션이 닫히고, 웹 브라우저는 문서를 보여준다.

#### 1.6.3 텔넷을 이용한 실제 예제

책 본문 참고 바람.

### 1.7 프로토콜 버전

* HTTP/0.9 : 오직 GET 메서드만 지원,  HTML 객체를 받기 위한 용도였으며 금방 1.0 VER로 대체되었다.
* HTTP/1.0 : 웹페이지와 상호작용하기 위한 다양한 기능이 추가되었으나, 잘 정의되지 않은, 용례들의 모음에 가깝다.
* HTTP/1.0+ : 비공식적으로나마 keep-alive 커넥션, 가상 호스팅, 프락시 연결 지원 등이 사실 상 표준으로 추가되었다.
* **HTTP/1.1** : HTTP의 설계 구조적 결함 교정, 성능 최적화, 잘못된 기능 제거에 초점을 맞추었다, 현재 사용되고 있는 Version이다.
* **HTTP/2.0** : 구글의 SPDY 프로토콜 기반으로 설계가 진행 중인 프로토콜이다.
* 
### 1.8 웹의 구성 요소

* **프락시** : 클라이언트와 서버 사이에 위치 **HTTP 중개 서버**
* **캐시** : 많이 찾는 웹 페이지를 클라이언트 가까이에 보관하는 HTTP 창고
* **게이트웨이** : 다른 애플리케이션과 연결된 특별한 웹 서버
* **터널** : HTTP 통신을 전달하기만 하는 특별한 프락시
* **에이전트** : 자동화된 HTTP 요청을 만드는 준 지능적\(semi-intelligent\) 웹 클라이언트

#### 1.8.1 프락시

웹 보안, 애플리케이션 통합, 성능 최적화를 위한 HTTP 구성 요소. 프락시는 클라이언트와 서버 사이에 위치하여, 클라이언트의 HTTP 요청을 중개하여, 클라이언트를 대신해 요청을 서버에 전달한다. 이 중개 과정에서 요청은 대개 수정이 된다. 이는 주로 보안을 위해 사용되며, 반대로 응답을 필터링하기도 한다. 예를 들어, 응답 내에 바이러스를 검출하거나 유해 콘텐츠를 차단하는 데에도 쓰인다.

#### 1.8.2 캐시

웹 캐시와 캐시 프락시는 **자주 찾는 것의 사본**을 저장해두는 특별한 **HTTP 프락시 서버**이다. 프락시는 클라이언트와 서버 사이에 중개한다고 했는데, 만일 요청의 결과가 이미 프락시가 가지고 있는 종류의 것이라면, 서버에 요청을 보내지 않고 프락시에서 처리한다. 이로 인해서 클라이언트는 더 빨리 문서를 다운로드할 수 있게 된다. HTTP는 캐시를 효율적으로 동작하게 하고 캐시된 컨텐츠를 최신으로 유지하면서, 동시에 프라이버시를 보호하기 위한 기능을 정의한다.

#### 1.8.3 게이트웨이

게이트웨이는 다른 서버들의 중개자 역할을 하는 특별한 서버이다. 주로 HTTP 트래픽을 다른 프로토콜로 변환하기 위해 사용하며, 언제나 자기 자신이 리소스를 가지고 있는 진짜 서버인 것처럼 동작한다. 따라서 클라이언트는, 자신과 통신하고 있는 개체가 게이트웨이임을 알 수 없다.

#### 1.8.4 터널

두 커넥션 사이에서 날\(Raw\) 데이터를 열어보지 않고 그대로 전달하는 HTTP 애플리케이션. 터널은 주로 비 HTTP 데이터를 하나 이상의 HTTP 연결을 통해 전송해주기 위해 사용된다. 비 HTTP 데이터, 예컨대 암호화된 SSL 트래픽을 전송하여 웹 트래픽만 허용하는 사내 방화벽 내부로 보낼 수 있다.

#### 1.8.5 에이전트

에이전트는 HTTP 요청을 만드는 클라이언트 프로그램이다. 웹 브라우저도 에이전트에 해당한다. 다른 종류로는 사람의 통제 없이 웹을 돌아다니며 HTTP 트랜잭션을 일으키고, 콘텐츠를 받아오는, ‘스파이더’, ‘웹로봇’ 같은 크롤링 엔진들도 있다. 검색 엔진도 이에 해당한다.

## 2장 URL과 리소스

* URL 문법, 여러 URL 컴포넌트가 어떤 의미를 가지며 무엇을 수행하는지
* 여러 웹 클라이언트가 지원하는 상대 URL, 확장 URL 같은 **단축 URL**에 대해서
* URL 인코딩과 문자 규칙
* 여러 인터넷 정보 시스템에 적용되는 공통 URL 스킴
* 기존 이름을 유지하며 객체들을 다른 장소로 옮기는 것을 가능하게 해주는 URN을 포함한 URL의 미래.

### 2.1 인터넷의 리소스 탐색하기

> [http://www.joes-hardware.com/seasonal/index-fall.html](http://www.joes-hardware.com/seasonal/index-fall.html) 이라는 URL을 불러오고 싶다고 해보자.

1. http는 URL의 **스킴**이다. 스킴은 웹 클라이언트가 리소스에 접근하는 방법을  의미한다. 이 경우에는 HTTP 프로토콜을 의미한다.
2. 두번째 부분은 www.joes-hardware.com 으로, 서버의 위치이다. 이는 리소스가 어디에 호스팅되어 있는지를 알려준다.
3. URL의 세 번째 부분인 /seasonal/index-fall.html은 리소스의 경로이다, 경로는 서버에 존재하는 로컬 리소스들 중에서 요청 받은 리소스가 무엇인지 알려준다.

이상으로, URL에는 어떻게\(스킴\), 어디에서\(호스트\), 무엇\(경로\)을 가져오는 지에 대한 설명을 모두 담고 있다.

#### 2.1.1 URL이 있기 전 암흑의 시대

웹과 URL이 있기 전에는 애플리케이션마다 다른 분류 방식을 사용했다. 그래서 접근 방법을 일일히 설명해야 했지만, 이제는 브라우저에서 URL을 입력하는 것만으로도 가능해졌다. 사용자는 뉴스를 보기 위해 뉴스 리더를 사용할 필요가 없어졌고, FTP 서버에 있는 파일을 접근하고자 FTP 클라이언트를 사용할 필요가 없어졌다. 메일을 보내거나 받기 위해 전자메일 프로그램을 쓸 필요도 없어졌다. URL은 브라우저가 더 영리하게 리소스에 접근하고 다루게 함으로써 온라인 세상을 단순화시킨다. **URL은 브라우저가 정보를 찾는 데 필요한 모든 것을 제공하며, 원하는 리소스가 어디에 위치하고 어떻게 가져오는지를 정의**한다.

### 2.2 URL 문법

URL로 모든 리소스를 찾을 수 있지만, URL 문법은 스킴에 따라서 달라진다. 단, 대부분의 URL은 일반 URL의 문법을 따르기에 서로 다른 스킴도 형태와 문법이 매우 유사하다. 여기서 말하는 대부분의 URL 스킴은, 일반적으로 아래의 9가지 문법을 따른다.

1. **스킴** : 서버에서 리소스를 가져오기 위해 사용해야 하는 프로토콜, 즉 방법.
2. **사용자 이름** : 몇몇 스킴은 리소스에 접근하기 위해 사용자 이름을 필요로 한다, 기본 값으로 “annoymous”를 가진다.
3. **비밀번호** : 사용자의 비밀번호를 가리키며, 사용자 이름에 콜론으로 이어서 기술한다.
4. **호스트** : 리소스를 호스팅하는 호스트 명이나 IP 주소.
5. **포트** : 리소스를 호스팅하는 서버가 열어 놓은 포트 번호, 많은 스킴이 기본 포트를 가지고 있다. HTTP는 80.
6. **경로** : 서버 내 리소스의 위치를 가리킨다.
7. **파라미터** : 입력 파라미터들을 기술하는 용도로 사용. 이름/값을 쌍으로 가지며, 세미콜론으로 구분하여 기술한다.
8. **질의** : 스킴에서 애플리케이션에 파라미터를 전달하는 용도로 쓰인다.
9. **프래그먼트** : 리소스의 조각이나 일부분을 가리킨다. URL의 끝에서 \#으로 구분된다.

#### 2.2.1 스킴 : 사용할 프로토콜

스킴 컴포넌트는 알파벳으로 시작해야 하고, URL의 나머지 부분들과 첫 번째 : 문자로 구분한다. 스킴 명은 대소문자를 구분하지 않는다.

#### 2.2.2 호스트와 포트

애플리케이션이 인터넷에 있는 리소스를 찾으려면 호스팅하는 장비와, 그 리소스에 접근할 수 있는 서버가 어디에 있는지 알아야 한다. URL 호스트와 포트 컴포넌트는 그 두 가지 정보를 제공한다. 호스트는 인터넷 상의 호스트 장비를 가리킨다. 이는 호스트명이나 IP 주소로 되어 있다. 포트 컴포넌트는 서버가 열어놓은 네트워크 포트를 의미한다.

#### 2.2.3 사용자 이름과 비밀번호

따로 조사해서 정리해볼 것.

#### 2.2.4 경로

리소스가 서버에서 어디에 있는지를 알려준다. 계층적 파일 시스템 경로 \(UNIX의 파일 시스템의 파일 경로\)와 유사하다. 각 경로 조각은 자체적인 파라미터 컴포넌트를 가질 수 있다. TODO : 여기서 말하는 경로 조각의 자체적인 파라미터가, 파라미터와, **사용자 이름과 비밀번호**와 구별되게 만드는 특징이 아닐까?

#### 2.2.5 파라미터

많은 스킴이 객체에 대한 호스트 및 경로 정보만으로는 리소스를 찾지 못한다. 어떤 포트를 열었는지, 사용자 이름과 비밀번호를 명시했는지 외에도, 더 많은 정보를 요구해야 할 때도 있다. 따라서 URL을 사용하는 애플리케이션이 리소스에 접근하려면 프로토콜 파라미터가 필요하다.

#### 2.2.6 질의

TODO : 질의가 query를 말한 게 아닐까?

웹 데이터 베이스 게이트웨이에 질의하기 위해서 사용한다.

#### 2.2.7 프래그먼트

리소스 안의 특정 절을 가리키기 위해서 사용한다. 예를 들어 텍스트 안에서 일정 부분만을 가리킬 때 사용된다. \#으로 구분한다. 예컨대 특정 호스트의 tools.html\#drills 라고 작성하였다면, tools.html에서 drills로 시작되는 구간으로 스크롤을 내린다.

### 2.3 단축 URL

웹 클라이언트는 몇몇 단축 URL을 인식하고 사용한다. 상대 URL은 리소스를 간결하게 기술하는 데에 사용할 수 있다. 많은 브라우저가, 사용자가 기억하고 있는 URL의 일부분을 입력하면 나머지를 자동으로 입력해주는 URL **‘자동 확장’** 기능을 지원한다.

#### 2.3.1 상대 URL

URL은 상대 URL과 절대 URL로 나뉜다. 지금까지 본 것은 모두 절대 URL인데, 절대 URL은 찾고자 하는 리소스로 접근하기 위한 모든 정보를 가지고 있다. 하지만 상대 URL는 모든 정보를 가지고 있지 않다. 이는 ‘./’와 같이 현재 주소로부터, 와 같은 축약된 의미들을 사용하기 때문이다. 상대 URL은 URL의 일부거나, 또는 프래그먼트이다. 이를 사용함으로써 문서 집합의 위치를 옮기더라도 잘 동작할 수 있게 됐다. URL을 처리하는 브라우저 같은 애플리케이션은 상대 URL과 절대 URL을 상호 변환할 수 있어야 한다.

**기저 URL**

변환 단계에서의 첫 단계는 기저 URL \(./이 의미하는 현재 위치\)를 찾는 것이다. 이를 위한 방법은 여러 가지가 있는데, 아래에 서술한다.

* 리소스에서 명시적으로 제공 : 어떤 리소스들은, HTML 내에서 BASE 태그를 사용하여 명시하기도 한다.
* 리소스를 포함하고 있는 기저 URL : 특정 URL이 위와 같이 BASE 태그를 사용하지 않았다면, 그 페이지를 기저 url로 가정한다.
* 기저 url이 없는 경우 : 절대 URL로만 이루어져 있는 경우거나, 불운하게도 불완전하거나 깨진 URL일 수 있다.
* 상대 참조 해석하기 : **그림 참고**

#### 2.3.2 URL 확장

* 호스트 명 확장 :**휴리스틱**만 이용하여 전체 호스트 명으로 확장한다.  naver를 입력하면 자동으로 www와 .com을 붙여서 완성해준다.
* 히스토리 확장 : 과거에 방문했던 URL 기록을 저장하여 선택할 수 있게 해준다.

### 2.4 안전하지 않은 문자

안전한 전송이란 정보가 유실될 위험 없이 URL을 전송할 수 있다는 것을 의미한다. URL은 문자가 제거되지 않게 상대적으로 작고 안전한 알파벳만 포함하도록 허락한다. 또한 가독성을 위해서, 혹여 변화늘 통해서 보이지 않거나, 원칙적으로 사용 불가능한 문자가 나올 수 있다고 하더라도 일상적으로 사용하는 것을 금했다.

#### 2.4.1 URL 문자 집합

보통 영어 중심으로 설정되어 있다. 역사적으로 많은 컴퓨터 애플리케이션들이 US-ASCII 문자 집합을 사용해왔다. 이는 문자를 서식화하고 신호를 주고 받기 위해서 7비트를 사용한다. \(영어 말고도 몇몇 제어 문자를 표현할 수 있다.\) 다만 URL 설계자들은 URL에 이스케이프 문자열을 쓸 수 있게 설계하였다. 이로써 **특정 문자나 데이터들을 인코딩할 수 있게 함으로써 이동성과 완성도를 높였다.**

#### 2.4.2 인코딩 체계

안전한 문자 집합을 이용하는 경우 표현의 한계가 있다. 따라서 URL에서 안전하지 않은 문자들을 표현할 수 있는 인코딩 방식이 고안되었다. 인코딩은 안전하지 않은 문자를 % 기호로 시작하여 ASCII로 표현되는 두 개의 16진수 숫자로 이루어진 이스케이프 문자로 바꾼다.

#### 2.4.3 문자 제한

몇몇 문자는 URL에서 특별한 의미로 예약되어 있다. 내용은 책 42P 참고.

#### 2.4.4 좀 더 알아보기

사실 URL에 안전하지 않은 문자를 넣더라도 전송 프로토콜에서는 문제가 발생하지 않는다. 다만 이런 문자를 인코딩하지 않고 넣는 것은 개발자의 실수다. 이런 문자를 넣게 될 경우 다른 애플리케이션에서, 그 문자가 특수한 의미를 가지는 경우에 문제가 발생할 수 있다.

