# 3장 정리 중



* 메시지가 어떻게 흘러가는가
* HTTP 메시지의 세 부분 \(시작줄, 헤더, 개체 본문\)
* 요청과 응답 메시지의 차이
* 요청 메시지가 지원하는 여러 기능\(method\)
* 응답 메시지가 반환하는 상태 코드\(status code\)
* 여러 HTTP 헤더들은 무슨 일을 하는가

### 별도 정리 및 의문점

entity란 무엇인가? [https://linuxism.ustd.ip.or.kr/45](https://linuxism.ustd.ip.or.kr/45)

안전한 메서드의 목적 \(61p\)이 정확히 무엇인지 이해가 가지 않습니다.

PUT : 요청의 본문을 가지고, 요청 URL의 이름대로 새 문서를 만들거나 교체하도록 하는 것이다. → 이 말의 의미가, PUT 메서드의 REST한 의미에 더 부합하는 것인지?

Preflighted method에 대해서 학습할 것

HTTP 1.1에 대한 명세 링크이다, 여기서 OPTIONS를 읽어 보았다 [https://tools.ietf.org/html/rfc2616\#section-9.2](https://tools.ietf.org/html/rfc2616#section-9.2)

커스텀 메서드 만들기

메서드 확장 [https://stackoverflow.com/questions/18304436/in-express-and-node-js-is-it-possible-to-extend-or-override-methods-of-the-resp](https://stackoverflow.com/questions/18304436/in-express-and-node-js-is-it-possible-to-extend-or-override-methods-of-the-resp)

Object.create\(\) 에 관한 설명 [https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global\_Objects/Object/create](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/create)

end-to-end Principle \(종단\)

"엄격하게 보내고 관대하게 받아들여라." - Postel의 법칙

## 3.1 메세지의 흐름

HTTP 메시지는 HTTP 애플리케이션 간에 주고 받는 `데이터 블록` 으로, 메시지의 내용과 의미를 설명하는 텍스트 메타 정보로 시작하여 선택적으로 데이터가 온다.

메시지는 클라이언트, 서버, 프락시 사이를 흐르며, `'인바운드'`, `'아웃바인드'`, `'업스트림'`, `'다운스트림'`은 메시지의 방향을 의미하는 용어이다.

### 3.1.1 메시지는 원 서버 방향을 인바운드하여 송신된다.

메시지가 클라이언트에서 서버로 올라가는 것을 `인바운드`, 반대로 사용자 에이전트, 즉 클라이언트 쪽으로 내려오는 것을 `아웃바인드`라고 한다.

### 3.1.2 다운스트림으로 흐르는 메시지

HTTP는 요청이냐 응답이냐에 관계없이 모두 다운스트림으로 흐른다. 메시지 발송자는 수신자의 `업스트림` 이라고 하고, 수신자는 `다운스트림`이라고 한다. 따라서 어느 한 쪽의 업스트림이면서 다운스트림일 수도 있다.

## 3.2 메시지의 각 부분

HTTP 메시지는 단순히 구조화된 블록이다. 각 메시지는 클라이언트로부터 요청, 서버로부터의 응답 중 하나를 포함한다. 메시지는 시작줄, 헤더 블록, 본문, 이렇게 세 부분으로 되어 있다.

시작줄은 이것이 어떠한 메시지인지에 대한 메타 정보를 담고 있고, 헤더 블록은 속성을, 본문은 데이터를 담고 있다. 본문은 없을 수도 있다.

시작줄과 헤더의 구분은 사실, 그저 `캐리지 리턴`과 `개행 문자`로 구성되어 있다. 다만 오래된 HTTP 어플리케이션이나 잘못 만든 HTTP 어플리케이션은 `개행문자`만으로 되어 있어 있는 경우도 있으니 그냥 개행문자만도 처리할 수 있어야 한다.

```text
HTTP/1.0 200 OK            // 시작줄
Content-type: text/plain   // 헤더
Content-Length: 19         // 헤더
Hi! I'm a message!         // 본문
```

### 3.2.1 메시지 문법

모든 HTTP는 요청 또는 응답이다. 요청은 서버로 어떤 동작을 요구하고, 응답은 그 결과를 반환한다. 요청과 응답은 기본 구조가 같다.

```text
// 요청
GET /specials/saw-blade.gif HTTP/1.0  // 메서드, 요청 URL, 버전
HOST: www.joes-hardware.com           // 헤더
                                      // 헤더와 본문 사이에는 공백 라인(CRLF)가 있다.
                                      // 본문

// 응답
HTTP/1.0 200 OK                       // 버전, 상태코드, 사유구절
Content-Type: image/gif               // 헤더
Content-Length: 8572
                                      // 헤더와 본문 사이에는 공백 라인(CRLF)가 있다.
                                      // 본문
```

요청은 위와 같이 메서드, 요청 URL, 버전과, 헤더, 엔터티 본문으로 구성되고, 응답은 버전과 상태코드, 사유구절, 헤더, 엔터티 본문으로 구성된다. 보다시피 첫번째 줄만이 다르다.

`메서드`는 클라이언트가 서버에 요구하는 것으로, GET, HEAD, POST 등의 한 단어로만 구성이 되어 있다. `요청 URL`은 리소스를 지칭하는 완전한 URL, 혹은 경로 구성 요소를 의미한다.

`버전`은 HTTP/&lt;메이저&gt;&lt;마이너&gt;의 형식을 따르며, 메이저와 마이너는 모두 정수이다. `상태코드`는 요청 중에 일어난 것을 설명하는 세 자리 숫자이다. 첫번째 자릿수는 상태의 일반적인 분류로, 성공 또는 에러 등을 나타낸다.

`사유구절`은 숫자로 된 상태코드를 설명해주는 짧은 문구다, 사실 사유구절은 읽히기 위해 존재하는 텍스트일 분, 아무런 의미를 가지지 못한다. 만약 상태코드가 동등하게 200이면 하나는 OK, 하나는 NOT OK여도 둘은 성공한 것으로 본다.

`헤더` 는 이름, 콜론, 선태적인 공백, 값, CRLF가 순서대로 나타나는 것으로, 없을 수도 있다. 다만 HTTP/1.1 같은 몇몇 버전에서는 반드시 포함되는 헤더 종류가 있다.

마지막으로 `엔터티 본문`은 임의의 데이터 블록을 포함한다. 메시지는 없을 수도 있고, 이런 경우 헤더와 본문 사이의 공백 라인이었던 CRLF로 끝나게 된다. 즉, 본문이 없어도 CRLF로 끝난다.

다만 많은 구현체가 이것을 잊곤 하니, 클라이언트와 서버는 CRLF가 없는 경우도 고려하여 만들어져야 한다, 각각의 요소에 대한 자세한 설명은 해당 챕터에서 이어서.

### 3.2.2 시작줄

모든 HTTP 메시지는 시작줄로 시작한다. 요청은 무엇을 해야 하는지, 응답은 무엇이 일어났는지를 담고 있다. 위에도 언급했지만, 아래처럼 풀어서 이야기해보자.

`요청줄`은 어떤 동작을 해야 하는지, 그것이 어디에 있는지를 지칭하는 요청 URL, 클라이언트가 어떤 HTTP 버전으로 말하고 있는지를 서버에 알려주는 HTTP 버전을 포함한다. 각각의 필드는 공백문자로 구분된다.

`응답줄`은 수행결과에 대한 상태 정보, 결과 데이터를 클라이언트에게 준다. 시작줄 혹은 응답줄에는, 응답 메시지에 쓰인 HTTP의 버전, 숫자로 된 상태 코드, 수행 상태를 설명하는 사유 구절이 있다. HTTP/1.0 이전에는 없었다.

요청줄은 `메서드`로 시작하는데, HTTP 명세는 공통 요청 메서드의 집합을 정의한다, 예를 들면,

* GET : 서버에서 어떤 문서를 가져온다.
* HEAD : 서버에서 어떤 문서의 '헤더'만 가져온다.
* POST : 서버에서 처리해야 할 데이터를 보낸다. 당연히 메시지의 본문을 가진다.
* PUT : 서버에서 요청 메시지의 본문을 저장한다. 당연히 메시지의 본문을 가진다.
* TRACE : 메시지가 프락시를 거쳐 서버에 도달하는 과정을 추적한다.
* DELETE : 서버에서 문서를 제거한다.

이 메서드들은 쓸 수도 안쓸 수도 있고, HTTP 자체가 추가적인 메서드를 구현할 수 있어서, 새로운 메서드를 정의할 수도 있다. 이런 경우에는 확장 메서드라고 부른다.

`상태 코드` 는 무엇이 일어났는지를 말한다. 사유구절이 사람에게 이해하기 편하다면, 컴퓨터가 처리하기에는 숫자가 더 좋다. 상태 코드를 확장할 경우에는 일반적인 이해 범주로 담아야 한다. \(ex. 성공한 경우면 2로 시작해야 한다.\)

`사유구절`은 상태코드와 일대일로 대응한다, 다만 어떠한 규칙도 없으며, 아무런 영향도 가지지 못한다, 그저 상태 코드를 보다 쉽게 이해하기 위한 메시지일 뿐이다.

`버전 번호`는 HTTP/x.y 형식으로 기술되며 자신의 프로토콜 버전을 상대에게 알려준다. 이는 서로 불가능한 기능을 사용하지 않으려는 배려이다. 오해하지 말아야 하는 것은 각자 자신이 이해할 수 있는 버전 한계를 말한다는 점이다.

이것을 상대가 준 메시지의 버전이라고 생각해선 안 된다.

### 3.2.3 헤더

HTTP 헤더 명세는 여러 헤더 필드를 정의한다. 애플리케이션은 자신만의 헤더를 만들 수도 있다. 분류는 아래와 같다.

`일반 헤더` 는 요청과 응답 양쪽에 모두 나타낼 수 있다.

`요청 헤더` 요청에 대한 부가 정보를 나타낸다.

`응답 헤더` 응답에 대한 부가 정보를 나타낸다.

`Entity 헤더` 는 본문 크기와 콘텐츠, 혹은 리소스 그 자체를 서술한다. Entity에 대한 의미는 별도 정리하겠다.

`확장 헤더` 는 명세에 정의되지 않은 새로운 헤더를 의미한다.

헤더는 키와 값으로 이루어진 한 쌍으로 이루어지며 한 줄로 표현되지만, 만일 너무 길다면 개행을 하되 하나의 스페이스 이상의 들여쓰기를 통해 앞 헤더의 연장선임을 표현해주어야 한다.

### 3.2.4 엔터티 본문

HTTP 메시지의 세 번째 부분은 선택적인 엔티티 본문이다. 이는 HTTP 메시지의 화물, 또는 옮기고자 하는 것 그 자체이다.

### 3.2.5 버전 0.9 메시지

HTTP/0.9는 HTTP 프로토콜의 초기 버전이다. 요청은 그저 메서드와 URL만을 가지고 있고 응답은 본문만을 가진다. 매우 단순한 구조로 이루어져 있어서 많은 상황에 대응할 수는 없지만, 여전히 구식 클라이언트, 서버 등이 있으니 주의.

## 3.3 메서드

모든 서버가 모든 메서드를 구현하지는 않는다. 기본적으로 서버는, 자신의 리소스에 대한 GET, POST 메서드만 구현해도 충분하다. 메서드들은 별도의 제한을 가질 수도 있다.

가령 DELETE 메서드를 구현한 서버는, 어떠한 리소스든 삭제할 수 있게 하는 것을 원치 않을 것이다. 이러한 제한은 후술한다.

### 3.3.1 안전한 메서드\(Safe Method\)

HTTP는 안전한 메서드라 불리는 메서드의 집합을 정의한다. GET과 HEAD 메서드는 안전한 메서드인데, 이는 두 메서드가 서버에 어떠한 작용도 없음을 의미한다. \(웹 개발자가 의도적으로 작용을 만들 수는 있다.\)

안전한 메서드의 목적 \(안전한 메서드를 구분하는 목적\)은, 서버에 영향을 줄 수 있는 메서드를 사용할 때, 사용자에게 그 사실을 알려줄 수 있는 HTTP 애플리케이션을 만들 수 있도록 함이다.

### 3.3.2 GET

가장 흔히 쓰이는 메서드. 리소스를 요청하기 위해 쓰인다.

### 3.3.3 HEAD

GET 방식과 같지만 본문을 제외하고 헤더만을 가져온다는 차이가 있다. 이를 통해서 아래의 효과를 볼 수 있다.

* 리소스를 가져오지 않고도 메타 데이터를 얻을 수 있다.
* 개체의 존재 여부를 확인할 수 있다.
* 리소스가 변경되었는지 검사할 수 있다.

서버 개발자들은 HEAD 메서드가 주는 정보가, GET 메서드가 주는 정보의 헤더와 정확히 일치하도록 설계해야 한다.

```text
service.use(function(req, res, next) {
    res.header("Access-Control-Allow-Origin", "*");
    res.header("Access-Control-Allow-Methods", "GET,HEAD,OPTIONS,POST,PUT");
    res.header("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept, Authorization");
    next();
  });
```

### 3.3.4 PUT

PUT 메서드는 서버에 문서를 쓴다. PUT으로 웹 페이지를 만들고 서버에 게시하도록 하는 것도 가능하다. PUT의 의미는 서버가, 요청의 본문을 가지고, 요청 URL의 이름대로 새 문서를 만들거나 교체하도록 하는 것이다.

PUT은 콘텐츠를 변경할 수 있도록 해주기 때문에, 많은 웹 서버가 PUT을 수행하기 전에 로그인을 요구한다.

### 3.3.5 POST

POST메서드는 서버에 입력 데이터를 전송하기 위해 설계되었다. POST는 서버에 데이터를 보내는 용도, PUT은 서버에 이미 있는 리소스에 데이터를 입력하기 위한 용도라고 보면 된다.

HTML에서는 폼을 지원하기 위해 사용되는데, 폼에 채워진 정보는 그대로 서버에 전송되고, 서버는 이를 필요로 하는 곳에 보낸다. \(ex. 서버 게이트웨이 프로그램\)

### 3.3.6 TRACE

클라이언트가 어떤 요청을 할 때, 그 요청은 `방화벽, 프락시, 게이트웨이 등의 애플리케이션을 통과`할 수 있다. 이들에게는 원래의 HTTP 요청을 수정할 수 있는 기회가 있다.

TRACE 메서드는 클라이언트에게 자신의 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려준다. TRACE 요청은 목적지 서버에서 루프백\(Loopback\) 진단을 시작한다.

전송의 마지막 단계에 있는 서버가 자신이 요청 받은 메시지를 본문에 넣어 그래도 돌려준다. 그 중간 지점과 첫 클라이언트들은, 다시 자신이 보낸 요청의 결과를 일일히 확인할 수 있게 된다.

다만 TRACE 메서드는 다른 메서드들에 대한 구분을 두지 않고 일관되게 다루지는 못한다.

### 3.3.7 OPTIONS

OPTIONS 메서드는 웹 서버에게 여러 가지 종류의 지원 범위에 대해 물어본다. 서버는 특정 리소스에 대해 어떤 메서드가 가능한지 물어볼 수 있다.

```text
HTTP/1.1 200 OK
Allow: GET, POST, PUT, OPTIONS
Context-length: 0
```

### 3.3.8 DELETE

DELETE 메서드는 삭제를 요청하는 메서드다. 하지만 삭제가 수행되는 것을 보장 못한다. 명세에서는 서버가 클라이언트에게 아무런 알림없이 요청을 무시하는 것을 허락하기 때문이다.

### 3.3.9 확장 메서드

HTTP는 필요에 따라 확장해도 문제가 없도록 설계되어 있어서, 새로운 기능을 추가해도 문제가 되진 않는다. 다만, 확장 메서드는 명세에는 정의되지 않아 있다. 아래처럼 만들어진 메서드들이 있다.

* LOCK : 사용자가 리소스를 잠근다.
* MKCOL : 사용자가 문서를 생성할 수 있게 해준다.
* COPY : 서버에 있는 리소스를 복사한다.
* MOVE : 서버에 있는 리소스를 옮긴다.

모든 확장 메서드가 형식을 갖춘 명세로 정의되지는 않으므로 주의해야 한다. 만약 본인이 만들 경우에도 마찬가지다. 본인이 만든 메서드를 이해하지 못하는 애플리케이션이 있을 수도 있다.

그러므로 확장 메서드는 최대한 관용적으로 만들어야 한다. 이를 존중하여, 만약 메서드가 종단 간 \(end-to-end principle\)을 망가뜨리지 않는다면 프락시는 메서드를 전달해줄 것이고, 반대의 경우에는 501을 보낼 것이다.

상태코드 501은 요청을 처리할 수 없다는 의미다, 즉 메서드를 알 수 없다는 의미로서 반환되는 것이다.

be conservative in what you send, be liberal in what you accept, 엄격하게 보내고 관대하게 받아들이라는 Postel의 법칙을 따르자.

## 3.4 상태 코드

상태코드는 5가지 범주로 나뉜다. 즉, 앞자리가 1부터 5까지 있다고 보면 된다. 상태 코드는 명확하다, 여기에 사유 구절이 들어가면 클라이언트가 트랙잭션을 이해하기 편해진다. \(사유 구절은 공식적인 가이드가 없다.\)

### 3.4.1 100-199: 정보성 상태 코드

HTTP/1.1 에서 도입된 것으로 비교적 최신의 것이며, 가치에 대해서는 아직 논란이다.

* 상태코드 `100` 사유구절 Continue :

  요청의 일부가 받아들여졌고, 클라이언트는 나머지 요청을 보내야 한다는 의미이다. 이것을 보낸 후에는 서버는 반드시 요청을 기다려야 한다.

  만들어진 의도는, 클라이언트가 본문을 전송하기 전에 서버가 받아들일 것인지에 대한 확인을 최적화하기 위한 용도였으나, 프로그래머를 혼란스럽게 하는 경향이 있다.

  * 클라이언트 측면

  원래대로면, 클라이언트는 본문을 보낼 경우와 보내지 않을 경우를 나눠서 요청의 헤더를 다르게 해 보내야 한다. 본문을 보낼 거면 100-continue Expect 헤더를 추가해서 보내야 한다.

  만일 이것을 혼동한다면 서버는 클라이언트가 본문을 보낼 거라고 기다릴 수도 있고, 나중에 보낸 데이터를 클라이언트가 본문을 보내기 시작했다고 착각할 수도 있기 때문이다.

  다만 초창기의 100 Continue 상태에 대한 혼란 때문에, 당시 개발된 애플리케이션들은 위의 잘못된 사례들이 발생할 가능성이 높다. 따라서 클라이언트 개발자들은 예상하지 못한 응답에도 대비할 필요가 생겨 버렸다.

  이건 지금 글을 적고 있는 내 개인적인 생각인데, 마치 지구 주변에 돌고 있는 인공위성 파편들을 떠올리게 한다.

  * 서버 측면

  클라이언트가 본문을 보내기 전에 요청을 보냈다면, 즉 100-continue Expect 헤더를 보냈다면 서버는 100 Continue 응답 혹은 에러 코드로 답해야 한다.

  서버가 100 Continue 응답을 보낼 기회를 갖기 전에 이미 본문 내용 중 일부, 또는 전체를 받았다면 서버는 이 상태 코드를 보낼 필요도 없다. 이미 계속 보내기로 결정되었기 때문이다.

  그러나 서버가 요청을 다 읽은 후에는 그 응답을 보내 주어야 한다.

  마지막으로 주의할 점은, 서버가 본문을 읽기 전, 또는 읽던 도중에 요청을 닫기로 했다면 그냥 닫아서는 안된다! 자세한 내용은 추후 4장의 "TCP 끊기와 리셋 에러"에서 설명한다.

  * 프락시 측면

  클라이언트로부터 100-continue 응답을 의도한 요청을 받은 프락시는 아래와 같이 행동해야 한다.

  1. 만약 다음 홉 \(next-hop\) 서버가 HTTP/1.1을 따르거나, 어떤 버전인지 알 수 없다면 Expect 헤더를 보내야 한다.
  2. 만약 이전 버전을 따른다는 것을 이미 알고 있다면 417 Expectation Failed 에러로 응답해야 한다.

     정리하자면, 중간 역할인 프락시가 볼 때 다음 홉 서버가 최신 버전의 HTTP 명세를 따른다면 Expect 헤더를 보내 본문을 보낼 것임을 알리고, 그게 아니라면 에러로 응답하라는 뜻.

  3. 이 때, 만일 1번과 같이 Expect 헤더를 보내기로 했다면, 그 응답 결과는 클라이언트에게 보내지 않는다, 클라이언트는 이것을 어떻게 처리할지에 대한 로직이 없기 때문이다.
  4. 프락시가 다음 홉 서버에 대한 상태와 HTTP 버전을 기억해둔다면, 100-continue 응답을 기대한 요청을 더 잘 다룰 수 있게 되므로 프락시에게도 이득이 된다.

### 3.4.2 200-299: 성공 상태 코드

클라이언트가 요청을 보내면 대개 성공한다. 서버는 성공을 의미하는 코드 배열을 가지고 있다.

* 상태코드 `200` 사유구절 OK : 요청이 정상이고, 엔터티 본문에 요청된 리소스를 포함하고 있다.
* 상태코드 `201` 사유 구절 Created :

  서버 개체를 생성하라는 요청 \(예를 들어 PUT\)을 위한 것. 생성된 리소스에 대한 구체적 참조가 담긴 Location 헤더와 함께, 그 리소스를 참조할 수 있는 여러 URL을 본문에 포함해야 한다.

  서버는 상태 코드를 보내기에 앞서 반드시 객체를 생성해야 한다.

* 상태코드 `202` 사유 구절 Accepted :

  요청은 받았으나 서버는 아직 수행하지 않는다는 의미를 담고 있다. 따라서 요청이 적합해 보인다는 의미지, 처리에 대한 보장을 하지 않는다. 다만 서버는, 가급적 응답 본문에 예상 처리 시간을 포함해줘야 한다.

  또는 그에\(예상 처리 시간\) 대한 정보를 어디서 얻을 수 있는지를 포함해줘도 된다.

* 상태코드 `203` 사유 구절 Non-Authoritative Information :

  원래대로면 성공했다는 의미로 200을 보내야 하지만, 해당 정보가 원래 서버가 아닌 리소스의 사본에서 왔을 경우, 즉 헤더를 검증하지 않은 경우에 발생한다. 원래 서버에서 온 것일 경우의 선택사항이다.

* 상태코드 `204` 사유 구절 No Content : 엔터티 본문이 없는 경우를 의미한다. 주로 웹 브라우저를 새 문서로 옮기지 않고 갱신할 때, 즉 폼을 리프래시 할 때에 사용한다.
* 상태코드 `205` 사유 구절 Reset Content : 주로 브라우저를 위해 사용하는 코드로, 브라우저에게 현재 html 폼에 채워진 모든 값을 비우라는 의미를 갖고 있다.
* 상태코드 `206` 사유 구절 Partial Content : 부분 혹은 범위 요청이 성공했다는 의미.

